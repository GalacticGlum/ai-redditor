import json
from celery import states
from celery.result import AsyncResult
from flask_expects_json import expects_json
from flask import Blueprint, current_app, g, jsonify, url_for

import ai_redditor_service.tasks as tasks
from ai_redditor_service.utils import validate_json
from ai_redditor_service.models import RecordType, RECORD_MODEL_CLASSES
from ai_redditor_service.extensions import celery as celery_app

bp = Blueprint('api', __name__, url_prefix='/api')

def error_response(message, status_code, **kwargs):
    response = jsonify(error=message, success=False, **kwargs)
    response.status_code = status_code

    return response

get_random_record_schema = {
    'type': 'object',
    'properties': {
        'is_custom': {
            'type': ['boolean', 'null'],
            'default': None
        }, 
        'is_generated': {
            'type': ['boolean', 'null'],
            'default': True
        },
        'count': {
            'type': [ 'integer' ],
            'default': 1
        }
    }
}

@bp.route('/r/<any(tifu, wp, phc):record_type>/random', methods=['POST'])
@expects_json(get_random_record_schema, fill_defaults=True)
def get_random_record(record_type):
    '''
    Gets a random record of the specified type. An optional JSON object
    can be specified to filter the records that are sampled.

    :param is_custom:
        A boolean value indicating whether the record was user generated with
        a custom prompt. If not specified or null (None), all values of this
        field are accepted. Defaults to None.       
    :param is_generated:
        A boolean value indicating whether the record was generated by the 
        GPT2 model, or if it is an original record from a dataset. If not
        specified or null (None), all values of this field are accepeted.
        Defaults to True.
    :param count:
        The number of records to retrieve. Defaults to 1. 
    :returns:
        A dictionary representing a single record if a single record is
        requested (i.e. ``count`` is 1); otherwise, a list of dictionaries 
        representing the records.

    '''

    filter_kwargs = {}
    is_custom = g.data['is_custom']
    if is_custom is not None:
        filter_kwargs['is_custom'] = is_custom
    
    is_generated = g.data['is_generated']
    if is_generated is not None:
        filter_kwargs['is_generated'] = is_generated

    # Convert record type argument to enum
    record_type = RecordType[record_type.upper()]
    records = RECORD_MODEL_CLASSES[record_type].select_random_n(g.data['count'], **filter_kwargs)
    if records is None or len(records) == 0:
        return error_response('No {} record could be found with the provided constraints'.format(
            record_type.name
        ), 404)

    result = records[0].to_dict() if len(records) == 1 else [record.to_dict() for record in records]        
    return jsonify(result), 201

generate_schema = {
    'type': 'object',
    'properties': {
        'prompt': {
            'type': ['object', 'null'],
            'default': None
        }
    }
}

query_answer_prompt_schema = {
    'type': 'object',
    'properties': {
        'post_title': {
            'type': ['string', 'null'],
            'default': None
        },
        'post_body': {
            'type': ['string', 'null'],
            'default': None
        },
    },
    'additionalProperties': False
}

phc_prompt_schema = {
    'type': 'object',
    'properties': {                
        'author': {
            'type': ['string', 'null'],
            'default': None
        },
        'likes': {
            'type': ['integer', 'null'],
            'default': None
        },
        'comment_body': {
            'type': ['string', 'null'],
            'default': None
        }
    },
    'additionalProperties': False
}

_PROMPT_SCHEMAS = {
    RecordType.TIFU: query_answer_prompt_schema,
    RecordType.WP: query_answer_prompt_schema,
    RecordType.PHC: phc_prompt_schema
}

@bp.route('/r/<any(tifu, wp, phc):record_type>/generate', methods=['POST'])
@expects_json(generate_schema, fill_defaults=True)
def generate_record(record_type):
    '''
    Generates a record of the specified type. An optional JSON object
    can be specified to this endpoint providing a prompt to the model.

    '''

    # Convert record type argument to enum
    record_type = RecordType[record_type.upper()]
    prompt = g.data['prompt']

    if record_type in _PROMPT_SCHEMAS:
        validate_json(prompt, _PROMPT_SCHEMAS[record_type])

    result = tasks.generate_record.delay(record_type, prompt, samples=1) 
    response_message = 'Queued up {} record generation.'.format(record_type.name)

    return jsonify(
        task_id=result.id,
        task_status_endpoint=url_for('api.generate_record_task_status', task_id=result.id),
        message=response_message,
        success=True
    ), 202

_RECORD_ROUTE_MAP = {
    RecordType.TIFU: 'tifu',
    RecordType.WP: 'writingprompts',
    RecordType.PHC: 'phc',
}

@bp.route('/r/generate/<string:task_id>')
def generate_record_task_status(task_id):
    '''
    Gets the status of a record generation task given its id.

    '''

    result_handle = AsyncResult(task_id, app=celery_app)
    is_ready = result_handle.ready()

    kwargs = {
        'is_ready': is_ready,
        'state': result_handle.state,
    }

    if is_ready:
        if result_handle.state == states.FAILURE:
            backend = result_handle.backend
            state_meta = backend.get(backend.get_key_for_task(result_handle.id))
            # The state meta is an encoded JSON string, so we have to decode and parse it.
            state_meta = json.loads(state_meta.decode())
            return error_response(state_meta['result']['error'], 500)
        else:
            record_type, uuids = result_handle.result
            if len(uuids) == 0:
                return error_response('Could not generate a record from the given prompt.', 400)
            
            kwargs['uuid'] = uuids[0]

            route = 'main.{}_page'.format(_RECORD_ROUTE_MAP[record_type])
            kwargs['permalink'] = url_for(route, uuid=uuids[0])

    status_code = 201 if is_ready else 202
    return jsonify(success=True, **kwargs), status_code